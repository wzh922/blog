# å®ç”¨ä»£ç 

## geojson è½¬ shp

```python
import geopandas as gpd
import pandas as pd
import os
from shapely.geometry import shape
import fiona

def geojson_to_shp(geojson_file, shp_file):
    """
    å°†GeoJSONæ–‡ä»¶è½¬æ¢ä¸ºShapefileæ–‡ä»¶
    
    å‚æ•°:
    geojson_file: è¾“å…¥çš„GeoJSONæ–‡ä»¶è·¯å¾„
    shp_file: è¾“å‡ºçš„Shapefileæ–‡ä»¶è·¯å¾„
    """
    try:
        # è¯»å–GeoJSONæ–‡ä»¶
        print(f"æ­£åœ¨è¯»å–GeoJSONæ–‡ä»¶: {geojson_file}")
        gdf = gpd.read_file(geojson_file)
        
        # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        output_dir = os.path.dirname(shp_file)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # ä¿å­˜ä¸ºShapefile
        print(f"æ­£åœ¨è½¬æ¢ä¸ºShapefile: {shp_file}")
        gdf.to_file(shp_file, encoding='utf-8')
        
        print("è½¬æ¢å®Œæˆ!")
        return True
        
    except Exception as e:
        print(f"è½¬æ¢è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        return False
 def read_shp_info(shp_file):
    """
    è¯»å–Shapefileæ–‡ä»¶å¹¶æ‰“å°å„ç§ä¿¡æ¯
    
    å‚æ•°:
    shp_file: Shapefileæ–‡ä»¶è·¯å¾„
    """
    try:
        # è¯»å–Shapefile
        print(f"\næ­£åœ¨è¯»å–Shapefileæ–‡ä»¶: {shp_file}")
        gdf = gpd.read_file(shp_file)
        
        # 1. åŸºæœ¬ä¿¡æ¯
        print("\n" + "="*50)
        print("ShapefileåŸºæœ¬ä¿¡æ¯")
        print("="*50)
        print(f"æ–‡ä»¶è·¯å¾„: {shp_file}")
        print(f"è¦ç´ æ•°é‡: {len(gdf)}")
        print(f"å‡ ä½•ç±»å‹: {gdf.geometry.type.unique()}")
        print(f"åæ ‡å‚è€ƒç³»(CRS): {gdf.crs}")
        
        # 2. å­—æ®µä¿¡æ¯
        print("\n" + "="*50)
        print("å­—æ®µä¿¡æ¯")
        print("="*50)
        print(f"å­—æ®µæ•°é‡: {len(gdf.columns)}")
        print("å­—æ®µè¯¦æƒ…:")
        for i, col in enumerate(gdf.columns, 1):
            dtype = gdf[col].dtype
            print(f"  {i}. {col} ({dtype})")
        
        # 3. å±æ€§è¡¨é¢„è§ˆ
        print("\n" + "="*50)
        print("å±æ€§è¡¨å‰5è¡Œ")
        print("="*50)
        print(gdf.head())
        
        # 4. ç©ºé—´èŒƒå›´
        print("\n" + "="*50)
        print("ç©ºé—´èŒƒå›´")
        print("="*50)
        bounds = gdf.total_bounds
        print(f"æœ€å°X: {bounds[0]:.6f}")
        print(f"æœ€å°Y: {bounds[1]:.6f}")
        print(f"æœ€å¤§X: {bounds[2]:.6f}")
        print(f"æœ€å¤§Y: {bounds[3]:.6f}")
        
        # 5. å‡ ä½•ä¿¡æ¯ç»Ÿè®¡
        print("\n" + "="*50)
        print("å‡ ä½•ä¿¡æ¯ç»Ÿè®¡")
        print("="*50)
        print(f"æ€»é¢ç§¯: {gdf.area.sum():.6f} å¹³æ–¹å•ä½")
        print(f"æ€»é•¿åº¦: {gdf.length.sum():.6f} å•ä½")
        
        # 6. å„å‡ ä½•ç±»å‹çš„æ•°é‡ç»Ÿè®¡
        print("\n" + "="*50)
        print("å‡ ä½•ç±»å‹ç»Ÿè®¡")
        print("="*50)
        geometry_counts = gdf.geometry.type.value_counts()
        for geom_type, count in geometry_counts.items():
            print(f"{geom_type}: {count} ä¸ª")
        
        # 7. ç©ºé—´å‚è€ƒç³»ç»Ÿè¯¦ç»†ä¿¡æ¯
        print("\n" + "="*50)
        print("åæ ‡å‚è€ƒç³»è¯¦ç»†ä¿¡æ¯")
        print("="*50)
        if gdf.crs is not None:
            crs_info = gdf.crs.to_dict()
            for key, value in crs_info.items():
                print(f"{key}: {value}")
        else:
            print("æœªå®šä¹‰åæ ‡å‚è€ƒç³»")
            
        # 8. å†…å­˜ä½¿ç”¨æƒ…å†µ
        print("\n" + "="*50)
        print("å†…å­˜ä½¿ç”¨ä¿¡æ¯")
        print("="*50)
        memory_usage = gdf.memory_usage(deep=True).sum()
        print(f"æ€»å†…å­˜ä½¿ç”¨: {memory_usage / 1024:.2f} KB")
        
        return gdf
        
    except Exception as e:
        print(f"è¯»å–Shapefileæ—¶å‘ç”Ÿé”™è¯¯: {e}")
        return None
geojson_file = r"D:\DownLoad\chrome\é»”ä¸œå—è‹—æ—ä¾—æ—è‡ªæ²»å·_å¿.geojson"  # æ›¿æ¢ä¸ºæ‚¨çš„GeoJSONæ–‡ä»¶è·¯å¾„
shp_file = "é»”ä¸œå—è‹—æ—ä¾—æ—è‡ªæ²»å·_å¿.shp"

# æ‰§è¡Œè½¬æ¢
print("\nå¼€å§‹GeoJSONåˆ°Shapefileçš„è½¬æ¢...")
success = geojson_to_shp(geojson_file, shp_file)

if success:
    # è¯»å–å¹¶æ˜¾ç¤ºShapefileä¿¡æ¯
    gdf = read_shp_info(shp_file)
    
    # å¯é€‰: æ˜¾ç¤ºæ›´å¤šè¯¦ç»†ä¿¡æ¯
    if gdf is not None:
        print("\n" + "="*50)
        print("å‰3ä¸ªè¦ç´ çš„è¯¦ç»†ä¿¡æ¯")
        print("="*50)
        for i, (idx, row) in enumerate(gdf.head(3).iterrows()):
            print(f"\nè¦ç´  {i+1}:")
            for col in gdf.columns:
                if col != 'geometry':
                    print(f"  {col}: {row[col]}")
            print(f"  å‡ ä½•ç±»å‹: {row.geometry.geom_type}")
            print(f"  é¢ç§¯: {row.geometry.area:.2f}")
            print(f"  è¾¹ç•Œ: {row.geometry.bounds}")

print("\nç¨‹åºæ‰§è¡Œå®Œæˆ!")
```

## åˆ‡åˆ†shpï¼Œåˆ‡åˆ†å¿

### åˆ‡åˆ†2å—

#### ä»£ç 

```python
import geopandas as gpd
import pandas as pd
import numpy as np
from shapely.geometry import Polygon, MultiPolygon, LineString
from shapely.ops import split
import os
import math

def split_polygon_into_two(polygon, split_direction='longest'):
    """
    å°†å¤šè¾¹å½¢åˆ‡åˆ†ä¸ºä¸¤éƒ¨åˆ†
    """
    try:
        if polygon.is_empty:
            return None, None
            
        # è·å–å¤šè¾¹å½¢çš„è¾¹ç•Œæ¡†
        minx, miny, maxx, maxy = polygon.bounds
        
        if split_direction == 'longest':
            # æŒ‰æœ€é•¿è¾¹æ–¹å‘åˆ‡åˆ†
            width = maxx - minx
            height = maxy - miny
            if width > height:
                split_direction = 'vertical'
            else:
                split_direction = 'horizontal'
        
        if split_direction == 'vertical':
            # å‚ç›´åˆ‡åˆ†ï¼ˆä¸œè¥¿æ–¹å‘ï¼‰
            mid_x = (minx + maxx) / 2
            split_line = LineString([(mid_x, miny - 1), (mid_x, maxy + 1)])
        else:
            # æ°´å¹³åˆ‡åˆ†ï¼ˆå—åŒ—æ–¹å‘ï¼‰
            mid_y = (miny + maxy) / 2
            split_line = LineString([(minx - 1, mid_y), (maxx + 1, mid_y)])
        
        # æ‰§è¡Œåˆ‡åˆ†
        split_parts = split(polygon, split_line)
        
        # è¿‡æ»¤æœ‰æ•ˆçš„å¤šè¾¹å½¢
        valid_parts = [part for part in split_parts.geoms 
                      if isinstance(part, (Polygon, MultiPolygon)) and not part.is_empty]
        
        if len(valid_parts) >= 2:
            return valid_parts[0], valid_parts[1]
        else:
            # å¦‚æœåˆ‡åˆ†ä¸æˆåŠŸï¼Œå°è¯•å¯¹è§’çº¿åˆ‡åˆ†
            return split_by_diagonal(polygon)
            
    except Exception as e:
        print(f"åˆ‡åˆ†å¤šè¾¹å½¢æ—¶å‡ºé”™: {e}")
        return split_by_diagonal(polygon)

def split_by_diagonal(polygon):
    """
    é€šè¿‡å¯¹è§’çº¿åˆ‡åˆ†çš„å¤‡é€‰æ–¹æ³•
    """
    try:
        minx, miny, maxx, maxy = polygon.bounds
        # ä»å·¦ä¸Šåˆ°å³ä¸‹
        split_line = LineString([(minx, maxy), (maxx, miny)])
        split_parts = split(polygon, split_line)
        
        valid_parts = [part for part in split_parts.geoms 
                      if isinstance(part, (Polygon, MultiPolygon)) and not part.is_empty]
        
        if len(valid_parts) >= 2:
            return valid_parts[0], valid_parts[1]
        else:
            # ä»å³ä¸Šåˆ°å·¦ä¸‹
            split_line = LineString([(maxx, maxy), (minx, miny)])
            split_parts = split(polygon, split_line)
            valid_parts = [part for part in split_parts.geoms 
                          if isinstance(part, (Polygon, MultiPolygon)) and not part.is_empty]
            
            if len(valid_parts) >= 2:
                return valid_parts[0], valid_parts[1]
            else:
                print("æ‰€æœ‰åˆ‡åˆ†æ–¹æ³•éƒ½å¤±è´¥ï¼Œè¿”å›åŸå§‹å¤šè¾¹å½¢")
                return polygon, polygon
    except Exception as e:
        print(f"å¯¹è§’çº¿åˆ‡åˆ†ä¹Ÿå¤±è´¥: {e}")
        return polygon, polygon

def auto_detect_town_field(gdf):
    """
    è‡ªåŠ¨æ£€æµ‹ä¹¡é•‡åå­—æ®µ
    """
    # å¸¸è§çš„ä¸­æ–‡ä¹¡é•‡å­—æ®µå
    town_keywords = ['é•‡', 'ä¹¡', 'è¡—é“', 'town', 'TOWN', 'name', 'NAME', 'åç§°', 'åœ°å']
    
    for field in gdf.columns:
        field_lower = str(field).lower()
        # æ£€æŸ¥å­—æ®µåæ˜¯å¦åŒ…å«ä¹¡é•‡ç›¸å…³å…³é”®è¯
        for keyword in town_keywords:
            if keyword.lower() in field_lower:
                return field
        
        # æ£€æŸ¥å­—æ®µå†…å®¹æ˜¯å¦åŒ…å«ä¹¡é•‡ç‰¹å¾
        sample_values = gdf[field].dropna().head(10)
        if len(sample_values) > 0:
            sample_str = ' '.join(str(x) for x in sample_values)
            if any(keyword in sample_str for keyword in ['é•‡', 'ä¹¡', 'è¡—é“']):
                return field
    
    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›ç¬¬ä¸€ä¸ªéå‡ ä½•å­—æ®µ
    non_geom_fields = [col for col in gdf.columns if col != gdf.geometry.name]
    return non_geom_fields[0] if non_geom_fields else gdf.columns[0]

def auto_detect_county_field(gdf):
    """
    è‡ªåŠ¨æ£€æµ‹å¿åå­—æ®µ
    """
    # å¸¸è§çš„ä¸­æ–‡å¿å­—æ®µå
    county_keywords = ['å¿', 'åŒº', 'å¸‚', 'county', 'COUNTY', 'city', 'CITY']
    
    for field in gdf.columns:
        field_lower = str(field).lower()
        for keyword in county_keywords:
            if keyword.lower() in field_lower:
                return field
        
        # æ£€æŸ¥å­—æ®µå†…å®¹æ˜¯å¦åŒ…å«å¿åŒºç‰¹å¾
        sample_values = gdf[field].dropna().head(10)
        if len(sample_values) > 0:
            sample_str = ' '.join(str(x) for x in sample_values)
            if any(keyword in sample_str for keyword in ['å¿', 'åŒº', 'å¸‚']):
                return field
    
    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•ç”¨ä¹¡é•‡å­—æ®µå
    town_field = auto_detect_town_field(gdf)
    if town_field != gdf.columns[0]:
        return gdf.columns[0]
    else:
        return "æœªçŸ¥å¿"

def clean_filename(name):
    """
    æ¸…ç†æ–‡ä»¶åï¼Œç§»é™¤éæ³•å­—ç¬¦
    """
    import re
    # ç§»é™¤Windowsæ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
    illegal_chars = r'[<>:"/\\|?*]'
    cleaned = re.sub(illegal_chars, '_', str(name))
    # ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºæ ¼å’Œç‚¹å·
    cleaned = cleaned.strip().strip('.')
    # é™åˆ¶æ–‡ä»¶åé•¿åº¦
    if len(cleaned) > 100:
        cleaned = cleaned[:100]
    return cleaned

def save_single_shapefile(gdf, output_path, file_name):
    """
    ä¿å­˜å•ä¸ªShapefileæ–‡ä»¶
    """
    try:
        # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        output_dir = os.path.dirname(output_path)
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
        
        # å®Œæ•´çš„æ–‡ä»¶è·¯å¾„
        full_path = os.path.join(output_path, f"{file_name}.shp")
        
        # ä¿å­˜ä¸ºShapefile
        gdf.to_file(full_path, encoding='utf-8')
        
        print(f"  å·²ä¿å­˜: {file_name}.shp")
        return True
        
    except Exception as e:
        print(f"  ä¿å­˜æ–‡ä»¶ {file_name}.shp æ—¶å‡ºé”™: {e}")
        return False

def split_towns_to_individual_files(shp_file, output_dir):
    """
    è‡ªåŠ¨è¯»å–å¿çº§shpæ–‡ä»¶ï¼Œå°†æ¯ä¸ªä¹¡é•‡åˆ‡åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå¹¶ä¿å­˜ä¸ºå•ç‹¬çš„shpæ–‡ä»¶
    
    å‚æ•°:
    shp_file: è¾“å…¥çš„å¿çº§Shapefileæ–‡ä»¶è·¯å¾„
    output_dir: è¾“å‡ºç›®å½•
    """
    
    # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    try:
        # è¯»å–Shapefile
        print(f"æ­£åœ¨è¯»å–æ–‡ä»¶: {shp_file}")
        gdf = gpd.read_file(shp_file)
        
        # è‡ªåŠ¨æ£€æµ‹å­—æ®µ
        town_field = auto_detect_town_field(gdf)
        county_field = auto_detect_county_field(gdf)
        
        print(f"æ£€æµ‹åˆ°å¿å­—æ®µ: {county_field}")
        print(f"æ£€æµ‹åˆ°ä¹¡é•‡å­—æ®µ: {town_field}")
        
        # æ˜¾ç¤ºå­—æ®µä¿¡æ¯
        print(f"\næ‰€æœ‰å­—æ®µ: {list(gdf.columns)}")
        print(f"å‡ ä½•ç±»å‹: {gdf.geometry.type.unique()}")
        print(f"è¦ç´ æ•°é‡: {len(gdf)}")
        
        # æ˜¾ç¤ºä¹¡é•‡åˆ—è¡¨
        towns = gdf[town_field].unique()
        print(f"\nå‘ç° {len(towns)} ä¸ªä¹¡é•‡:")
        for i, town in enumerate(towns, 1):
            print(f"  {i}. {town}")
        
        # è·å–å¿å
        if county_field in gdf.columns and len(gdf[county_field].unique()) == 1:
            county_name = gdf[county_field].iloc[0]
        else:
            # ä»æ–‡ä»¶åæå–å¿åæˆ–ä½¿ç”¨é»˜è®¤å€¼
            county_name = os.path.basename(shp_file).replace('.shp', '')
            print(f"ä½¿ç”¨æ–‡ä»¶åä½œä¸ºå¿å: {county_name}")
        
        # æ¸…ç†å¿åç”¨äºæ–‡ä»¶å
        county_name_clean = clean_filename(county_name)
        
        # åˆ›å»ºå¿ç›®å½•
        county_dir = os.path.join(output_dir, county_name_clean)
        if not os.path.exists(county_dir):
            os.makedirs(county_dir)
        
        print(f"\nå¼€å§‹åˆ‡åˆ†å¹¶ä¿å­˜ä¹¡é•‡æ–‡ä»¶...")
        print("="*60)
        
        success_count = 0
        fail_count = 0
        total_files_created = 0
        
        for idx, row in gdf.iterrows():
            town_name = row[town_field]
            geometry = row.geometry
            
            print(f"\nå¤„ç†ä¹¡é•‡: {town_name}")
            
            # æ¸…ç†ä¹¡é•‡åç”¨äºæ–‡ä»¶å
            town_name_clean = clean_filename(town_name)
            
            # å¤„ç†MultiPolygon
            if isinstance(geometry, MultiPolygon):
                polygons = list(geometry.geoms)
            else:
                polygons = [geometry]
            
            town_parts = []
            
            for poly_idx, polygon in enumerate(polygons):
                # åˆ‡åˆ†å¤šè¾¹å½¢
                part1, part2 = split_polygon_into_two(polygon)
                
                if part1 is not None and part2 is not None and not part1.equals(part2):
                    town_parts.extend([part1, part2])
                    print(f"  âœ“ æˆåŠŸåˆ‡åˆ†ç¬¬{poly_idx+1}ä¸ªå¤šè¾¹å½¢")
                else:
                    # å¦‚æœåˆ‡åˆ†å¤±è´¥ï¼Œä½¿ç”¨è¾¹ç•Œæ¡†åˆ‡åˆ†
                    print(f"  âš  ç¬¬{poly_idx+1}ä¸ªå¤šè¾¹å½¢åˆ‡åˆ†ä¸ç†æƒ³ï¼Œä½¿ç”¨è¾¹ç•Œæ¡†åˆ‡åˆ†")
                    part1, part2 = split_by_bounds(polygon)
                    if part1 is not None and part2 is not None and not part1.equals(part2):
                        town_parts.extend([part1, part2])
                    else:
                        print(f"  âœ— ç¬¬{poly_idx+1}ä¸ªå¤šè¾¹å½¢åˆ‡åˆ†å®Œå…¨å¤±è´¥ï¼Œä¿ç•™åŸçŠ¶")
                        town_parts.append(polygon)
            
            # ä¸ºæ¯ä¸ªéƒ¨åˆ†åˆ›å»ºå•ç‹¬çš„shpæ–‡ä»¶
            for i, part in enumerate(town_parts[:2], 1):  # åªå–å‰ä¸¤ä¸ªéƒ¨åˆ†
                # åˆ›å»ºæ–°çš„GeoDataFrame
                new_row = row.copy()
                new_row.geometry = part
                # æ·»åŠ åˆ‡åˆ†ä¿¡æ¯
                new_row['SPLIT_ID'] = f"{county_name}-{town_name}-{i}"
                new_row['ORIGINAL_TOWN'] = town_name
                new_row['SPLIT_PART'] = i
                new_row['COUNTY_NAME'] = county_name
                
                single_gdf = gpd.GeoDataFrame([new_row], crs=gdf.crs)
                
                # ç”Ÿæˆæ–‡ä»¶å
                file_name = f"{county_name_clean}-{town_name_clean}-{i}"
                
                # ä¿å­˜ä¸ºå•ç‹¬çš„shpæ–‡ä»¶
                if save_single_shapefile(single_gdf, county_dir, file_name):
                    total_files_created += 1
                    print(f"  âœ“ ä¿å­˜: {file_name}.shp")
                else:
                    print(f"  âœ— ä¿å­˜å¤±è´¥: {file_name}.shp")
            
            if len(town_parts) >= 2:
                success_count += 1
            else:
                fail_count += 1
        
        print(f"\n" + "="*60)
        print(f"å¤„ç†å®Œæˆ!")
        print("="*60)
        print(f"åŸå§‹ä¹¡é•‡æ•°é‡: {len(gdf)}")
        print(f"æˆåŠŸåˆ‡åˆ†: {success_count} ä¸ªä¹¡é•‡")
        print(f"åˆ‡åˆ†å¤±è´¥: {fail_count} ä¸ªä¹¡é•‡")
        print(f"åˆ›å»ºçš„shpæ–‡ä»¶æ€»æ•°: {total_files_created}")
        print(f"è¾“å‡ºç›®å½•: {county_dir}")
        
        # æ˜¾ç¤ºç”Ÿæˆçš„æ–‡ä»¶åˆ—è¡¨
        print(f"\nç”Ÿæˆçš„æ–‡ä»¶åˆ—è¡¨:")
        shp_files = [f for f in os.listdir(county_dir) if f.endswith('.shp')]
        for i, file in enumerate(shp_files[:20], 1):  # åªæ˜¾ç¤ºå‰20ä¸ªæ–‡ä»¶
            print(f"  {i}. {file}")
        
        if len(shp_files) > 20:
            print(f"  ... è¿˜æœ‰ {len(shp_files) - 20} ä¸ªæ–‡ä»¶")
        
        # ä¿å­˜å¤„ç†æ—¥å¿—
        save_processing_log(county_dir, county_name, gdf, success_count, fail_count, total_files_created)
        
        return total_files_created
        
    except Exception as e:
        print(f"å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return 0

def split_by_bounds(polygon):
    """
    ä½¿ç”¨è¾¹ç•Œæ¡†è¿›è¡Œåˆ‡åˆ†
    """
    try:
        minx, miny, maxx, maxy = polygon.bounds
        center_x, center_y = (minx + maxx) / 2, (miny + maxy) / 2
        
        # åˆ›å»ºå››ä¸ªè±¡é™çš„çŸ©å½¢
        rect1 = Polygon([(minx, miny), (center_x, miny), (center_x, center_y), (minx, center_y), (minx, miny)])
        rect2 = Polygon([(center_x, miny), (maxx, miny), (maxx, center_y), (center_x, center_y), (center_x, miny)])
        rect3 = Polygon([(minx, center_y), (center_x, center_y), (center_x, maxy), (minx, maxy), (minx, center_y)])
        rect4 = Polygon([(center_x, center_y), (maxx, center_y), (maxx, maxy), (center_x, maxy), (center_x, center_y)])
        
        # ä¸åŸå§‹å¤šè¾¹å½¢æ±‚äº¤
        parts = []
        for rect in [rect1, rect2, rect3, rect4]:
            intersection = polygon.intersection(rect)
            if not intersection.is_empty and intersection.area > 0:
                if isinstance(intersection, MultiPolygon):
                    parts.extend(list(intersection.geoms))
                else:
                    parts.append(intersection)
        
        # æŒ‰é¢ç§¯æ’åºï¼Œå–å‰ä¸¤ä¸ªæœ€å¤§çš„éƒ¨åˆ†
        parts.sort(key=lambda x: x.area, reverse=True)
        if len(parts) >= 2:
            return parts[0], parts[1]
        elif len(parts) == 1:
            return parts[0], parts[0]
        else:
            return polygon, polygon
            
    except Exception as e:
        print(f"è¾¹ç•Œæ¡†åˆ‡åˆ†å¤±è´¥: {e}")
        return polygon, polygon

def save_processing_log(output_dir, county_name, original_gdf, success_count, fail_count, total_files):
    """
    ä¿å­˜å¤„ç†æ—¥å¿—
    """
    try:
        log_file = os.path.join(output_dir, f"å¤„ç†æ—¥å¿—.txt")
        
        with open(log_file, 'w', encoding='utf-8') as f:
            f.write(f"ä¹¡é•‡åˆ‡åˆ†å¤„ç†æ—¥å¿—\n")
            f.write(f"=" * 50 + "\n")
            f.write(f"å¤„ç†æ—¶é—´: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"å¿åç§°: {county_name}\n")
            f.write(f"åŸå§‹ä¹¡é•‡æ•°é‡: {len(original_gdf)}\n")
            f.write(f"æˆåŠŸåˆ‡åˆ†: {success_count} ä¸ªä¹¡é•‡\n")
            f.write(f"åˆ‡åˆ†å¤±è´¥: {fail_count} ä¸ªä¹¡é•‡\n")
            f.write(f"ç”Ÿæˆçš„shpæ–‡ä»¶æ€»æ•°: {total_files}\n")
            f.write(f"\nåŸå§‹ä¹¡é•‡åˆ—è¡¨:\n")
            
            town_field = auto_detect_town_field(original_gdf)
            for town in original_gdf[town_field].unique():
                f.write(f"  - {town}\n")
        
        print(f"å¤„ç†æ—¥å¿—å·²ä¿å­˜: {log_file}")
        
    except Exception as e:
        print(f"ä¿å­˜å¤„ç†æ—¥å¿—æ—¶å‡ºé”™: {e}")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # è¾“å…¥æ–‡ä»¶è·¯å¾„ - æ›¿æ¢ä¸ºæ‚¨çš„å¿çº§Shapefileè·¯å¾„
    input_shp = "é»”ä¸œå—è‹—æ—ä¾—æ—è‡ªæ²»å·_å¿.shp"  # æ‚¨çš„å¿çº§shpæ–‡ä»¶
    output_directory = input_shp.split('.')[0]
    
    print("å¼€å§‹è‡ªåŠ¨åˆ‡åˆ†ä¹¡é•‡å¹¶ä¿å­˜ä¸ºå•ç‹¬æ–‡ä»¶...")
    print("="*60)
    
    # æ‰§è¡Œåˆ‡åˆ†
    files_created = split_towns_to_individual_files(
        shp_file=input_shp,
        output_dir=output_directory
    )
    
    if files_created > 0:
        print(f"\n" + "="*60)
        print("å¤„ç†å®Œæˆï¼")
        print("="*60)
        print(f"æ€»å…±ç”Ÿæˆäº† {files_created} ä¸ªshpæ–‡ä»¶")
        print(f"æ–‡ä»¶å‘½åæ ¼å¼: å¿å-é•‡å-ç¼–å·.shp")
        print(f"ç¤ºä¾‹: æŸå¿-æŸé•‡-1.shp, æŸå¿-æŸé•‡-2.shp")
    else:
        print("\nå¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¾“å…¥æ–‡ä»¶å’Œé”™è¯¯ä¿¡æ¯ã€‚")
```

#### æ•ˆæœ

![image-20251107164010369](D:\Code\MarkDown\img\image-20251107164010369.png)

### åˆ‡åˆ†å¤šå—

#### ä»£ç 

```python
import geopandas as gpd
import pandas as pd
import numpy as np
from shapely.geometry import Polygon, MultiPolygon, LineString, Point
from shapely.ops import split, voronoi_diagram
import os
import math

def split_polygon_into_n_parts(polygon, n_parts=2, method='grid'):
    """
    å°†å¤šè¾¹å½¢åˆ‡åˆ†ä¸ºNéƒ¨åˆ†
    
    å‚æ•°:
    polygon: è¦åˆ‡åˆ†çš„å¤šè¾¹å½¢
    n_parts: åˆ‡åˆ†æ•°é‡ (2, 3, 4)
    method: åˆ‡åˆ†æ–¹æ³• ('grid', 'voronoi', 'radial')
    """
    try:
        if polygon.is_empty:
            return [polygon] * n_parts
            
        # è·å–å¤šè¾¹å½¢çš„è¾¹ç•Œæ¡†
        minx, miny, maxx, maxy = polygon.bounds
        
        if method == 'grid':
            return split_by_grid(polygon, n_parts)
        elif method == 'voronoi':
            return split_by_voronoi(polygon, n_parts)
        elif method == 'radial':
            return split_by_radial(polygon, n_parts)
        else:
            return split_by_grid(polygon, n_parts)
            
    except Exception as e:
        print(f"åˆ‡åˆ†å¤šè¾¹å½¢æ—¶å‡ºé”™: {e}")
        # å¦‚æœåˆ‡åˆ†å¤±è´¥ï¼Œè¿”å›åŸå§‹å¤šè¾¹å½¢çš„å¤šä¸ªå‰¯æœ¬
        return [polygon] * n_parts

def split_by_grid(polygon, n_parts):
    """
    ä½¿ç”¨ç½‘æ ¼æ–¹æ³•åˆ‡åˆ†å¤šè¾¹å½¢
    """
    minx, miny, maxx, maxy = polygon.bounds
    width = maxx - minx
    height = maxy - miny
    
    parts = []
    
    if n_parts == 2:
        # 2ç­‰åˆ†
        if width > height:
            # å‚ç›´åˆ‡åˆ†
            mid_x = (minx + maxx) / 2
            split_line = LineString([(mid_x, miny - 1), (mid_x, maxy + 1)])
        else:
            # æ°´å¹³åˆ‡åˆ†
            mid_y = (miny + maxy) / 2
            split_line = LineString([(minx - 1, mid_y), (maxx + 1, mid_y)])
        
        split_parts = split(polygon, split_line)
        parts = [part for part in split_parts.geoms if not part.is_empty]
        
    elif n_parts == 3:
        # 3ç­‰åˆ† - æ ¹æ®é•¿å®½æ¯”å†³å®šåˆ‡åˆ†æ–¹å‘
        if width > height:
            # å‚ç›´ä¸‰ç­‰åˆ†
            x1 = minx + width / 3
            x2 = minx + 2 * width / 3
            split_line1 = LineString([(x1, miny - 1), (x1, maxy + 1)])
            split_line2 = LineString([(x2, miny - 1), (x2, maxy + 1)])
        else:
            # æ°´å¹³ä¸‰ç­‰åˆ†
            y1 = miny + height / 3
            y2 = miny + 2 * height / 3
            split_line1 = LineString([(minx - 1, y1), (maxx + 1, y1)])
            split_line2 = LineString([(minx - 1, y2), (maxx + 1, y2)])
        
        # ç¬¬ä¸€æ¬¡åˆ‡åˆ†
        temp_parts = split(polygon, split_line1)
        parts = []
        for part in temp_parts.geoms:
            if not part.is_empty:
                # ç¬¬äºŒæ¬¡åˆ‡åˆ†
                sub_parts = split(part, split_line2)
                parts.extend([p for p in sub_parts.geoms if not p.is_empty])
                
    elif n_parts == 4:
        # 4ç­‰åˆ† - åå­—åˆ‡åˆ†
        mid_x = (minx + maxx) / 2
        mid_y = (miny + maxy) / 2
        
        # å‚ç›´åˆ‡åˆ†çº¿
        vert_line = LineString([(mid_x, miny - 1), (mid_x, maxy + 1)])
        # æ°´å¹³åˆ‡åˆ†çº¿
        horz_line = LineString([(minx - 1, mid_y), (maxx + 1, mid_y)])
        
        # å…ˆå‚ç›´åˆ‡åˆ†
        temp_parts = split(polygon, vert_line)
        parts = []
        for part in temp_parts.geoms:
            if not part.is_empty:
                # å†æ°´å¹³åˆ‡åˆ†
                sub_parts = split(part, horz_line)
                parts.extend([p for p in sub_parts.geoms if not p.is_empty])
    
    # è¿‡æ»¤æœ‰æ•ˆçš„å¤šè¾¹å½¢å¹¶ç¡®ä¿æ•°é‡æ­£ç¡®
    valid_parts = [part for part in parts if isinstance(part, (Polygon, MultiPolygon)) and not part.is_empty]
    
    if len(valid_parts) >= n_parts:
        # æŒ‰é¢ç§¯æ’åºï¼Œå–å‰n_partsä¸ªæœ€å¤§çš„éƒ¨åˆ†
        valid_parts.sort(key=lambda x: x.area, reverse=True)
        return valid_parts[:n_parts]
    else:
        # å¦‚æœåˆ‡åˆ†å‡ºçš„éƒ¨åˆ†ä¸å¤Ÿï¼Œä½¿ç”¨è¾¹ç•Œæ¡†æ–¹æ³•
        return split_by_bounds(polygon, n_parts)

def split_by_voronoi(polygon, n_parts):
    """
    ä½¿ç”¨Voronoiå›¾æ–¹æ³•åˆ‡åˆ†å¤šè¾¹å½¢
    """
    try:
        minx, miny, maxx, maxy = polygon.bounds
        center_x, center_y = (minx + maxx) / 2, (miny + maxy) / 2
        
        # ç”Ÿæˆéšæœºç‚¹ï¼ˆåœ¨è¾¹ç•Œæ¡†å†…ï¼‰
        points = []
        for _ in range(n_parts):
            # åœ¨è¾¹ç•Œæ¡†å†…éšæœºç”Ÿæˆç‚¹ï¼Œä½†åå‘ä¸­å¿ƒåŒºåŸŸ
            x = np.random.uniform(minx + 0.2*(maxx-minx), maxx - 0.2*(maxx-minx))
            y = np.random.uniform(miny + 0.2*(maxy-miny), maxy - 0.2*(maxy-miny))
            points.append(Point(x, y))
        
        # æ·»åŠ ä¸­å¿ƒç‚¹ç¡®ä¿è¦†ç›–
        points.append(Point(center_x, center_y))
        
        # åˆ›å»ºVoronoiå›¾
        voronoi = voronoi_diagram(MultiPoint(points))
        
        parts = []
        for region in voronoi.geoms:
            if region.intersects(polygon):
                intersection = region.intersection(polygon)
                if not intersection.is_empty:
                    parts.append(intersection)
        
        # æŒ‰é¢ç§¯æ’åºï¼Œå–å‰n_partsä¸ªæœ€å¤§çš„éƒ¨åˆ†
        parts.sort(key=lambda x: x.area, reverse=True)
        return parts[:n_parts] if len(parts) >= n_parts else split_by_bounds(polygon, n_parts)
        
    except Exception as e:
        print(f"Voronoiåˆ‡åˆ†å¤±è´¥: {e}")
        return split_by_bounds(polygon, n_parts)

def split_by_radial(polygon, n_parts):
    """
    ä½¿ç”¨å¾„å‘åˆ‡åˆ†æ–¹æ³•
    """
    try:
        centroid = polygon.centroid
        minx, miny, maxx, maxy = polygon.bounds
        
        parts = []
        angle_step = 360 / n_parts
        
        for i in range(n_parts):
            # è®¡ç®—å¾„å‘çº¿çš„è§’åº¦
            angle1 = math.radians(i * angle_step)
            angle2 = math.radians((i + 1) * angle_step)
            
            # åˆ›å»ºæ‰‡å½¢ï¼ˆä»ä¸­å¿ƒåˆ°è¾¹ç•Œï¼‰
            distance = math.sqrt((maxx-minx)**2 + (maxy-miny)**2)
            x1 = centroid.x + distance * math.cos(angle1)
            y1 = centroid.y + distance * math.sin(angle1)
            x2 = centroid.x + distance * math.cos(angle2)
            y2 = centroid.y + distance * math.sin(angle2)
            
            # åˆ›å»ºä¸‰è§’å½¢æ‰‡å½¢
            triangle = Polygon([(centroid.x, centroid.y), (x1, y1), (x2, y2), (centroid.x, centroid.y)])
            
            # ä¸åŸå§‹å¤šè¾¹å½¢æ±‚äº¤
            intersection = polygon.intersection(triangle)
            if not intersection.is_empty:
                parts.append(intersection)
        
        return parts if len(parts) >= n_parts else split_by_bounds(polygon, n_parts)
        
    except Exception as e:
        print(f"å¾„å‘åˆ‡åˆ†å¤±è´¥: {e}")
        return split_by_bounds(polygon, n_parts)

def split_by_bounds(polygon, n_parts):
    """
    ä½¿ç”¨è¾¹ç•Œæ¡†æ–¹æ³•åˆ‡åˆ†å¤šè¾¹å½¢
    """
    try:
        minx, miny, maxx, maxy = polygon.bounds
        
        if n_parts == 2:
            # 2ç­‰åˆ†
            mid_x = (minx + maxx) / 2
            rect1 = Polygon([(minx, miny), (mid_x, miny), (mid_x, maxy), (minx, maxy), (minx, miny)])
            rect2 = Polygon([(mid_x, miny), (maxx, miny), (maxx, maxy), (mid_x, maxy), (mid_x, miny)])
            parts = [rect1.intersection(polygon), rect2.intersection(polygon)]
            
        elif n_parts == 3:
            # 3ç­‰åˆ†
            x1 = minx + (maxx - minx) / 3
            x2 = minx + 2 * (maxx - minx) / 3
            rect1 = Polygon([(minx, miny), (x1, miny), (x1, maxy), (minx, maxy), (minx, miny)])
            rect2 = Polygon([(x1, miny), (x2, miny), (x2, maxy), (x1, maxy), (x1, miny)])
            rect3 = Polygon([(x2, miny), (maxx, miny), (maxx, maxy), (x2, maxy), (x2, miny)])
            parts = [rect1.intersection(polygon), rect2.intersection(polygon), rect3.intersection(polygon)]
            
        elif n_parts == 4:
            # 4ç­‰åˆ†
            mid_x = (minx + maxx) / 2
            mid_y = (miny + maxy) / 2
            rect1 = Polygon([(minx, miny), (mid_x, miny), (mid_x, mid_y), (minx, mid_y), (minx, miny)])
            rect2 = Polygon([(mid_x, miny), (maxx, miny), (maxx, mid_y), (mid_x, mid_y), (mid_x, miny)])
            rect3 = Polygon([(minx, mid_y), (mid_x, mid_y), (mid_x, maxy), (minx, maxy), (minx, mid_y)])
            rect4 = Polygon([(mid_x, mid_y), (maxx, mid_y), (maxx, maxy), (mid_x, maxy), (mid_x, mid_y)])
            parts = [rect1.intersection(polygon), rect2.intersection(polygon), 
                    rect3.intersection(polygon), rect4.intersection(polygon)]
        
        # è¿‡æ»¤ç©ºçš„éƒ¨åˆ†
        valid_parts = [part for part in parts if not part.is_empty]
        return valid_parts if len(valid_parts) >= n_parts else [polygon] * n_parts
        
    except Exception as e:
        print(f"è¾¹ç•Œæ¡†åˆ‡åˆ†å¤±è´¥: {e}")
        return [polygon] * n_parts

def auto_detect_town_field(gdf):
    """è‡ªåŠ¨æ£€æµ‹ä¹¡é•‡åå­—æ®µ"""
    town_keywords = ['é•‡', 'ä¹¡', 'è¡—é“', 'town', 'TOWN', 'name', 'NAME', 'åç§°', 'åœ°å']
    for field in gdf.columns:
        field_lower = str(field).lower()
        for keyword in town_keywords:
            if keyword.lower() in field_lower:
                return field
    non_geom_fields = [col for col in gdf.columns if col != gdf.geometry.name]
    return non_geom_fields[0] if non_geom_fields else gdf.columns[0]

def auto_detect_county_field(gdf):
    """è‡ªåŠ¨æ£€æµ‹å¿åå­—æ®µ"""
    county_keywords = ['å¿', 'åŒº', 'å¸‚', 'county', 'COUNTY', 'city', 'CITY']
    for field in gdf.columns:
        field_lower = str(field).lower()
        for keyword in county_keywords:
            if keyword.lower() in field_lower:
                return field
    town_field = auto_detect_town_field(gdf)
    return gdf.columns[0] if town_field != gdf.columns[0] else "æœªçŸ¥å¿"

def clean_filename(name):
    """æ¸…ç†æ–‡ä»¶å"""
    import re
    illegal_chars = r'[<>:"/\\|?*]'
    cleaned = re.sub(illegal_chars, '_', str(name))
    cleaned = cleaned.strip().strip('.')
    if len(cleaned) > 100:
        cleaned = cleaned[:100]
    return cleaned

def split_towns_to_individual_files(shp_file, output_dir, n_parts=2, method='grid'):
    """
    å°†æ¯ä¸ªä¹¡é•‡åˆ‡åˆ†ä¸ºNéƒ¨åˆ†ï¼Œå¹¶ä¿å­˜ä¸ºå•ç‹¬çš„shpæ–‡ä»¶
    
    å‚æ•°:
    shp_file: è¾“å…¥çš„å¿çº§Shapefileæ–‡ä»¶è·¯å¾„
    output_dir: è¾“å‡ºç›®å½•
    n_parts: åˆ‡åˆ†æ•°é‡ (2, 3, 4)
    method: åˆ‡åˆ†æ–¹æ³• ('grid', 'voronoi', 'radial')
    """
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    try:
        print(f"æ­£åœ¨è¯»å–æ–‡ä»¶: {shp_file}")
        gdf = gpd.read_file(shp_file)
        
        town_field = auto_detect_town_field(gdf)
        county_field = auto_detect_county_field(gdf)
        
        print(f"æ£€æµ‹åˆ°å¿å­—æ®µ: {county_field}")
        print(f"æ£€æµ‹åˆ°ä¹¡é•‡å­—æ®µ: {town_field}")
        print(f"åˆ‡åˆ†æ•°é‡: {n_parts}å—")
        print(f"åˆ‡åˆ†æ–¹æ³•: {method}")
        
        # è·å–å¿å
        if county_field in gdf.columns and len(gdf[county_field].unique()) == 1:
            county_name = gdf[county_field].iloc[0]
        else:
            county_name = os.path.basename(shp_file).replace('.shp', '')
        
        county_name_clean = clean_filename(county_name)
        county_dir = os.path.join(output_dir, f"{county_name_clean}_{n_parts}ç­‰åˆ†")
        if not os.path.exists(county_dir):
            os.makedirs(county_dir)
        
        print(f"\nå¼€å§‹åˆ‡åˆ†å¹¶ä¿å­˜ä¹¡é•‡æ–‡ä»¶...")
        print("="*60)
        
        success_count = 0
        fail_count = 0
        total_files_created = 0
        
        for idx, row in gdf.iterrows():
            town_name = row[town_field]
            geometry = row.geometry
            
            print(f"\nå¤„ç†ä¹¡é•‡: {town_name}")
            town_name_clean = clean_filename(town_name)
            
            if isinstance(geometry, MultiPolygon):
                polygons = list(geometry.geoms)
            else:
                polygons = [geometry]
            
            all_parts = []
            
            for poly_idx, polygon in enumerate(polygons):
                print(f"  åˆ‡åˆ†ç¬¬{poly_idx+1}ä¸ªå¤šè¾¹å½¢...")
                parts = split_polygon_into_n_parts(polygon, n_parts, method)
                all_parts.extend(parts)
                print(f"  âœ“ æˆåŠŸåˆ‡åˆ†ä¸º {len(parts)} éƒ¨åˆ†")
            
            # ä¸ºæ¯ä¸ªéƒ¨åˆ†åˆ›å»ºå•ç‹¬çš„shpæ–‡ä»¶
            for i, part in enumerate(all_parts[:n_parts], 1):  # åªå–å‰n_partsä¸ªéƒ¨åˆ†
                new_row = row.copy()
                new_row.geometry = part
                new_row['SPLIT_ID'] = f"{county_name}-{town_name}-{i}"
                new_row['ORIGINAL_TOWN'] = town_name
                new_row['SPLIT_PART'] = i
                new_row['COUNTY_NAME'] = county_name
                new_row['TOTAL_PARTS'] = n_parts
                
                single_gdf = gpd.GeoDataFrame([new_row], crs=gdf.crs)
                
                file_name = f"{county_name_clean}-{town_name_clean}-{i}"
                output_path = os.path.join(county_dir, f"{file_name}.shp")
                
                try:
                    single_gdf.to_file(output_path, encoding='utf-8')
                    total_files_created += 1
                    print(f"  âœ“ ä¿å­˜: {file_name}.shp (é¢ç§¯: {part.area:.2f})")
                except Exception as e:
                    print(f"  âœ— ä¿å­˜å¤±è´¥: {file_name}.shp - {e}")
            
            if len(all_parts) >= n_parts:
                success_count += 1
            else:
                fail_count += 1
        
        print(f"\n" + "="*60)
        print(f"å¤„ç†å®Œæˆ!")
        print("="*60)
        print(f"åŸå§‹ä¹¡é•‡æ•°é‡: {len(gdf)}")
        print(f"æˆåŠŸåˆ‡åˆ†: {success_count} ä¸ªä¹¡é•‡")
        print(f"åˆ‡åˆ†å¤±è´¥: {fail_count} ä¸ªä¹¡é•‡")
        print(f"åˆ›å»ºçš„shpæ–‡ä»¶æ€»æ•°: {total_files_created}")
        print(f"è¾“å‡ºç›®å½•: {county_dir}")
        
        # æ˜¾ç¤ºç”Ÿæˆçš„æ–‡ä»¶åˆ—è¡¨
        shp_files = [f for f in os.listdir(county_dir) if f.endswith('.shp')]
        print(f"\nç”Ÿæˆçš„æ–‡ä»¶åˆ—è¡¨ (å‰20ä¸ª):")
        for i, file in enumerate(shp_files[:20], 1):
            print(f"  {i}. {file}")
        
        if len(shp_files) > 20:
            print(f"  ... è¿˜æœ‰ {len(shp_files) - 20} ä¸ªæ–‡ä»¶")
        
        return total_files_created
        
    except Exception as e:
        print(f"å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return 0

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    input_shp = "é»”ä¸œå—è‹—æ—ä¾—æ—è‡ªæ²»å·_å¿.shp"
    output_directory = "ä¹¡é•‡åˆ‡åˆ†ç»“æœ"
    
    # å¯ä»¥é€‰æ‹©åˆ‡åˆ†æ•°é‡å’Œåˆ‡åˆ†æ–¹æ³•
    n_parts = 3  # å¯ä»¥æ”¹ä¸º 2, 3, 4
    method = 'grid'  # å¯ä»¥æ”¹ä¸º 'grid', 'voronoi', 'radial'
    
    print(f"å¼€å§‹è‡ªåŠ¨åˆ‡åˆ†ä¹¡é•‡ä¸º {n_parts} å—...")
    print("="*60)
    
    files_created = split_towns_to_individual_files(
        shp_file=input_shp,
        output_dir=output_directory,
        n_parts=n_parts,
        method=method
    )
    
    if files_created > 0:
        print(f"\nå¤„ç†å®Œæˆï¼æ€»å…±ç”Ÿæˆäº† {files_created} ä¸ªshpæ–‡ä»¶")
        print(f"æ–‡ä»¶å‘½åæ ¼å¼: å¿å-é•‡å-ç¼–å·.shp")
        print(f"ç¤ºä¾‹: æŸå¿-æŸé•‡-1.shp, æŸå¿-æŸé•‡-2.shp, æŸå¿-æŸé•‡-3.shp")
```

#### æ•ˆæœ

![image-20251107164421396](D:\Code\MarkDown\img\image-20251107164421396.png)

## åˆ‡åˆ†shpï¼Œåˆ‡åˆ†é•‡ï¼ˆå¤šå—ï¼‰

é¦–å…ˆéœ€è¦æœ‰çœå¸‚å¿é•‡å››çº§è¡Œæ”¿åŒºåˆ’çš„æ•°æ®ï¼Œæˆ‘çš„æ•°æ®æ¥æºï¼šç‚¹ç‚¹GISå…¬ä¼—å·ï¼Œ[å“”å“©å“”å“©](https://www.bilibili.com/video/BV1eR4y1m7Pm/?spm_id_from=333.337.search-card.all.click&vd_source=c0981ce15cd64f30336d91bc5a665dee)â€”>é€‚åˆåˆ‡åˆ†å¤šä¸ªä¹¡é•‡

é€šè¿‡ç½‘ç›˜åˆ†äº«çš„æ–‡ä»¶ï¼š2021å¹´7æœˆä¸­å›½ä¹¡é•‡è¡Œæ”¿åŒºåˆ’shp.rar
é“¾æ¥: https://pan.baidu.com/s/1bnG5ShtNTe0uL3KAVMf6Jg?pwd=nefu æå–ç : nefu 
--æ¥è‡ªç™¾åº¦ç½‘ç›˜è¶…çº§ä¼šå‘˜v4çš„åˆ†äº«

æˆ–è€…åˆ°[äº”çº§åŒºåˆ’æŸ¥è¯¢ä¸ä¸‹è½½](https://map.ruiduobao.com/)æŒ¨ä¸ªæœç´¢ï¼Œè¦éº»çƒ¦ä¸€äº›â€”>é€‚åˆåˆ‡åˆ†å•ä¸ªä¹¡é•‡

### ä»£ç 

#### ç‰ˆæœ¬1ï¼Œæ•´ä¸ªçœçš„ä¹¡é•‡è¾¹ç•Œåˆ‡å‰²

```python
import geopandas as gpd
import pandas as pd
import numpy as np
from shapely.geometry import Polygon, MultiPolygon, LineString
from shapely.ops import split
import os
import math
import warnings
from tqdm import tqdm

# å¿½ç•¥æ‰€æœ‰è­¦å‘Š
warnings.filterwarnings('ignore')

def read_shp_with_encoding(shp_file):
    """å°è¯•å¤šç§ç¼–ç æ–¹å¼è¯»å–SHPæ–‡ä»¶"""
    encodings = ['gbk', 'gb2312', 'utf-8', 'latin1', 'cp936', 'big5']
    
    for encoding in encodings:
        try:
            gdf = gpd.read_file(shp_file, encoding=encoding)
            return gdf, encoding
        except:
            continue
    
    try:
        gdf = gpd.read_file(shp_file)
        return gdf, 'unknown'
    except Exception as e:
        print(f"âŒ è¯»å–æ–‡ä»¶å¤±è´¥: {e}")
        return None, None

def split_polygon_into_n_parts(polygon, n_parts=2):
    """å°†å¤šè¾¹å½¢åˆ‡åˆ†ä¸ºNéƒ¨åˆ†"""
    try:
        if polygon.is_empty:
            return [polygon] * n_parts
            
        minx, miny, maxx, maxy = polygon.bounds
        width = maxx - minx
        height = maxy - miny
        
        parts = []
        
        if n_parts == 2:
            if width > height:
                mid_x = (minx + maxx) / 2
                split_line = LineString([(mid_x, miny - 1), (mid_x, maxy + 1)])
            else:
                mid_y = (miny + maxy) / 2
                split_line = LineString([(minx - 1, mid_y), (maxx + 1, mid_y)])
            
            split_parts = split(polygon, split_line)
            parts = [part for part in split_parts.geoms if not part.is_empty]
            
        elif n_parts == 3:
            if width > height:
                x1 = minx + width / 3
                x2 = minx + 2 * width / 3
                split_line1 = LineString([(x1, miny - 1), (x1, maxy + 1)])
                split_line2 = LineString([(x2, miny - 1), (x2, maxy + 1)])
            else:
                y1 = miny + height / 3
                y2 = miny + 2 * height / 3
                split_line1 = LineString([(minx - 1, y1), (maxx + 1, y1)])
                split_line2 = LineString([(minx - 1, y2), (maxx + 1, y2)])
            
            temp_parts = split(polygon, split_line1)
            parts = []
            for part in temp_parts.geoms:
                if not part.is_empty:
                    sub_parts = split(part, split_line2)
                    parts.extend([p for p in sub_parts.geoms if not p.is_empty])
                    
        elif n_parts == 4:
            mid_x = (minx + maxx) / 2
            mid_y = (miny + maxy) / 2
            
            vert_line = LineString([(mid_x, miny - 1), (mid_x, maxy + 1)])
            horz_line = LineString([(minx - 1, mid_y), (maxx + 1, mid_y)])
            
            temp_parts = split(polygon, vert_line)
            parts = []
            for part in temp_parts.geoms:
                if not part.is_empty:
                    sub_parts = split(part, horz_line)
                    parts.extend([p for p in sub_parts.geoms if not p.is_empty])
        
        valid_parts = [part for part in parts if isinstance(part, (Polygon, MultiPolygon)) and not part.is_empty]
        
        if len(valid_parts) >= n_parts:
            valid_parts.sort(key=lambda x: x.area, reverse=True)
            return valid_parts[:n_parts]
        else:
            return [polygon] * n_parts
            
    except Exception:
        return [polygon] * n_parts

def auto_detect_admin_fields(gdf):
    """è‡ªåŠ¨æ£€æµ‹è¡Œæ”¿åŒºåˆ’å­—æ®µ"""
    admin_keywords = {
        'name': ['name', 'åç§°', 'åœ°å']
    }
    
    detected_fields = {}
    
    for field in gdf.columns:
        if field == 'geometry':
            continue
            
        field_lower = field.lower()
        for field_type, keywords in admin_keywords.items():
            for keyword in keywords:
                if keyword.lower() in field_lower:
                    if field_type not in detected_fields:
                        detected_fields[field_type] = field
                    break
    
    if 'name' not in detected_fields:
        non_geom_fields = [col for col in gdf.columns if col != 'geometry']
        if non_geom_fields:
            detected_fields['name'] = non_geom_fields[0]
    
    return detected_fields

def clean_town_name(name):
    """æ¸…ç†ä¹¡é•‡åç§°"""
    import re
    if name is None:
        return "æœªçŸ¥ä¹¡é•‡"
    
    illegal_chars = r'[<>:"/\\|?*]'
    cleaned = re.sub(illegal_chars, '', str(name))
    cleaned = cleaned.strip().strip('.')
    
    if len(cleaned) > 50:
        cleaned = cleaned[:50]
    
    if not cleaned:
        cleaned = "æœªçŸ¥ä¹¡é•‡"
    
    return cleaned

def get_field_value(row, field_name):
    """å®‰å…¨è·å–å­—æ®µå€¼"""
    if field_name and field_name in row:
        value = row[field_name]
        return value if pd.notna(value) and value != "" else None
    return None

def split_all_towns_silent(town_shp_file, output_base_dir, n_parts=2):
    """
    é™é»˜ç‰ˆæœ¬ï¼šæ‰¹é‡åˆ‡åˆ†æ‰€æœ‰ä¹¡é•‡ï¼Œå¿½ç•¥è­¦å‘Š
    """
    if not os.path.exists(output_base_dir):
        os.makedirs(output_base_dir)
    
    try:
        print("ğŸ“¥ è¯»å–ä¹¡é•‡æ•°æ®...")
        town_gdf, encoding = read_shp_with_encoding(town_shp_file)
        
        if town_gdf is None:
            print("âŒ æ— æ³•è¯»å–ä¹¡é•‡æ–‡ä»¶")
            return 0
        
        town_fields = auto_detect_admin_fields(town_gdf)
        
        print(f"ğŸ“Š æ‰¾åˆ° {len(town_gdf)} ä¸ªä¹¡é•‡")
        print(f"ğŸ”ª å¼€å§‹åˆ‡åˆ†ä¸º {n_parts} å—...")
        
        total_files_created = 0
        success_count = 0
        
        # ä½¿ç”¨è¿›åº¦æ¡
        with tqdm(total=len(town_gdf), desc="åˆ‡åˆ†è¿›åº¦") as pbar:
            for idx, row in town_gdf.iterrows():
                town_name = get_field_value(row, town_fields.get('name')) or f"ä¹¡é•‡_{idx+1}"
                town_name_clean = clean_town_name(town_name)
                
                geometry = row.geometry
                if isinstance(geometry, MultiPolygon):
                    polygons = list(geometry.geoms)
                else:
                    polygons = [geometry]
                
                # åˆ›å»ºä¹¡é•‡ç›®å½•
                town_dir = os.path.join(output_base_dir, town_name_clean)
                if not os.path.exists(town_dir):
                    os.makedirs(town_dir)
                
                # åˆ‡åˆ†æ¯ä¸ªå¤šè¾¹å½¢
                all_parts = []
                for polygon in polygons:
                    parts = split_polygon_into_n_parts(polygon, n_parts)
                    all_parts.extend(parts)
                
                # ä¿å­˜åˆ‡åˆ†ç»“æœ
                parts_created = 0
                for i, part in enumerate(all_parts[:n_parts], 1):
                    new_row = row.copy()
                    new_row.geometry = part
                    
                    # æ·»åŠ åˆ‡åˆ†ä¿¡æ¯
                    new_row['SPLIT_ID'] = f"{town_name_clean}-{i}"
                    new_row['ORIGINAL_TOWN'] = town_name
                    new_row['SPLIT_PART'] = i
                    new_row['TOTAL_PARTS'] = n_parts
                    
                    single_gdf = gpd.GeoDataFrame([new_row], geometry='geometry', crs=town_gdf.crs)
                    
                    file_name = f"{town_name_clean}-{i}"
                    output_path = os.path.join(town_dir, f"{file_name}.shp")
                    
                    try:
                        single_gdf.to_file(output_path, encoding='utf-8')
                        total_files_created += 1
                        parts_created += 1
                    except Exception:
                        pass
                
                if parts_created > 0:
                    success_count += 1
                
                pbar.update(1)
        
        print(f"\nğŸ‰ åˆ‡åˆ†å®Œæˆ!")
        print(f"ğŸ“Š ç»Ÿè®¡ä¿¡æ¯:")
        print(f"  â€¢ æ€»ä¹¡é•‡æ•°é‡: {len(town_gdf)}")
        print(f"  â€¢ æˆåŠŸå¤„ç†: {success_count} ä¸ªä¹¡é•‡")
        print(f"  â€¢ åˆ›å»ºæ–‡ä»¶: {total_files_created} ä¸ª")
        
        return total_files_created
        
    except Exception as e:
        print(f"âŒ å¤„ç†å¤±è´¥: {e}")
        return 0

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # æ–‡ä»¶è·¯å¾„é…ç½®
    town_shp_file = "data/è´µå·çœ/è´µå·çœ_ä¹¡é•‡è¾¹ç•Œ.shp"
    output_base_dir = "è´µå·çœä¹¡é•‡åˆ‡åˆ†ç»“æœ"
    n_parts = 4
    
    print("ğŸ—ºï¸  ä¹¡é•‡è¾¹ç•Œåˆ‡åˆ†å·¥å…· (é™é»˜ç‰ˆ)")
    print("=" * 40)
    
    files_created = split_all_towns_silent(
        town_shp_file=town_shp_file,
        output_base_dir=output_base_dir,
        n_parts=n_parts
    )
    
    if files_created > 0:
        print(f"âœ… ä»»åŠ¡å®Œæˆ! ç”Ÿæˆ {files_created} ä¸ªæ–‡ä»¶")
    else:
        print(f"âŒ å¤„ç†å¤±è´¥")
```

#### ç‰ˆæœ¬2ï¼Œå•ä¸ªä¹¡é•‡åˆ‡å‰²

```python
import geopandas as gpd
import pandas as pd
import numpy as np
from shapely.geometry import Polygon, MultiPolygon, LineString
from shapely.ops import split
import os
import math
import warnings
from tqdm import tqdm

# å¿½ç•¥æ‰€æœ‰è­¦å‘Š
warnings.filterwarnings('ignore')

def read_shp_with_encoding(shp_file):
    """å°è¯•å¤šç§ç¼–ç æ–¹å¼è¯»å–SHPæ–‡ä»¶"""
    encodings = ['gbk', 'gb2312', 'utf-8', 'latin1', 'cp936', 'big5']
    
    for encoding in encodings:
        try:
            gdf = gpd.read_file(shp_file, encoding=encoding)
            return gdf, encoding
        except:
            continue
    
    try:
        gdf = gpd.read_file(shp_file)
        return gdf, 'unknown'
    except Exception as e:
        print(f"âŒ è¯»å–æ–‡ä»¶å¤±è´¥: {e}")
        return None, None

def split_polygon_into_n_parts(polygon, n_parts=2):
    """å°†å¤šè¾¹å½¢åˆ‡åˆ†ä¸ºNéƒ¨åˆ†"""
    try:
        if polygon.is_empty:
            return [polygon] * n_parts
            
        minx, miny, maxx, maxy = polygon.bounds
        width = maxx - minx
        height = maxy - miny
        
        parts = []
        
        if n_parts == 2:
            if width > height:
                mid_x = (minx + maxx) / 2
                split_line = LineString([(mid_x, miny - 1), (mid_x, maxy + 1)])
            else:
                mid_y = (miny + maxy) / 2
                split_line = LineString([(minx - 1, mid_y), (maxx + 1, mid_y)])
            
            split_parts = split(polygon, split_line)
            parts = [part for part in split_parts.geoms if not part.is_empty]
            
        elif n_parts == 3:
            if width > height:
                x1 = minx + width / 3
                x2 = minx + 2 * width / 3
                split_line1 = LineString([(x1, miny - 1), (x1, maxy + 1)])
                split_line2 = LineString([(x2, miny - 1), (x2, maxy + 1)])
            else:
                y1 = miny + height / 3
                y2 = miny + 2 * height / 3
                split_line1 = LineString([(minx - 1, y1), (maxx + 1, y1)])
                split_line2 = LineString([(minx - 1, y2), (maxx + 1, y2)])
            
            temp_parts = split(polygon, split_line1)
            parts = []
            for part in temp_parts.geoms:
                if not part.is_empty:
                    sub_parts = split(part, split_line2)
                    parts.extend([p for p in sub_parts.geoms if not p.is_empty])
                    
        elif n_parts == 4:
            mid_x = (minx + maxx) / 2
            mid_y = (miny + maxy) / 2
            
            vert_line = LineString([(mid_x, miny - 1), (mid_x, maxy + 1)])
            horz_line = LineString([(minx - 1, mid_y), (maxx + 1, mid_y)])
            
            temp_parts = split(polygon, vert_line)
            parts = []
            for part in temp_parts.geoms:
                if not part.is_empty:
                    sub_parts = split(part, horz_line)
                    parts.extend([p for p in sub_parts.geoms if not p.is_empty])
        
        valid_parts = [part for part in parts if isinstance(part, (Polygon, MultiPolygon)) and not part.is_empty]
        
        if len(valid_parts) >= n_parts:
            valid_parts.sort(key=lambda x: x.area, reverse=True)
            return valid_parts[:n_parts]
        else:
            return [polygon] * n_parts
            
    except Exception:
        return [polygon] * n_parts

def get_town_name_from_file(shp_file, gdf):
    """ä»SHPæ–‡ä»¶è·å–ä¹¡é•‡åç§°"""
    # å°è¯•ä»å­—æ®µä¸­è·å–
    name_fields = ['åç§°', 'åœ°å', 'name', 'NAME', 'ä¹¡é•‡å', 'é•‡å', 'town', 'TOWN']
    
    for field in name_fields:
        if field in gdf.columns and len(gdf) > 0:
            town_name = gdf[field].iloc[0]
            if pd.notna(town_name) and town_name != "":
                return str(town_name).strip()
    
    # ä»æ–‡ä»¶åæå–
    base_name = os.path.splitext(os.path.basename(shp_file))[0]
    suffixes = ['_è¾¹ç•Œ', '_polygon', '_town', '_ä¹¡é•‡', '_boundary', '_shp']
    
    town_name = base_name
    for suffix in suffixes:
        if town_name.endswith(suffix):
            town_name = town_name[:-len(suffix)]
            break
    
    return town_name

def clean_town_name(name):
    """æ¸…ç†ä¹¡é•‡åç§°"""
    import re
    if name is None:
        return "æœªçŸ¥ä¹¡é•‡"
    
    illegal_chars = r'[<>:"/\\|?*]'
    cleaned = re.sub(illegal_chars, '', str(name))
    cleaned = cleaned.strip().strip('.')
    
    if len(cleaned) > 50:
        cleaned = cleaned[:50]
    
    if not cleaned:
        cleaned = "æœªçŸ¥ä¹¡é•‡"
    
    return cleaned

def split_single_town_shp(shp_file, output_base_dir, n_parts=2):
    """
    åˆ‡åˆ†å•ä¸ªä¹¡é•‡SHPæ–‡ä»¶
    ä¿å­˜ä¸º: è¾“å‡ºç›®å½•/ä¹¡é•‡å/ä¹¡é•‡å-ç¼–å·.shp
    """
    if not os.path.exists(output_base_dir):
        os.makedirs(output_base_dir)
    
    try:
        print(f"ğŸ“¥ è¯»å–æ–‡ä»¶: {os.path.basename(shp_file)}")
        gdf, encoding = read_shp_with_encoding(shp_file)
        
        if gdf is None:
            print("âŒ æ— æ³•è¯»å–SHPæ–‡ä»¶")
            return 0
        
        # è·å–ä¹¡é•‡åç§°
        town_name = get_town_name_from_file(shp_file, gdf)
        town_name_clean = clean_town_name(town_name)
        
        print(f"ğŸ˜ï¸  ä¹¡é•‡åç§°: {town_name_clean}")
        print(f"ğŸ“Š è¦ç´ æ•°é‡: {len(gdf)}")
        
        # åˆ›å»ºä¹¡é•‡ç›®å½•
        town_dir = os.path.join(output_base_dir, town_name_clean)
        if not os.path.exists(town_dir):
            os.makedirs(town_dir)
        
        total_files_created = 0
        
        print(f"ğŸ”ª å¼€å§‹åˆ‡åˆ†ä¸º {n_parts} å—...")
        
        # ä½¿ç”¨è¿›åº¦æ¡
        with tqdm(total=len(gdf), desc="åˆ‡åˆ†è¿›åº¦") as pbar:
            for idx, row in gdf.iterrows():
                geometry = row.geometry
                
                if isinstance(geometry, MultiPolygon):
                    polygons = list(geometry.geoms)
                else:
                    polygons = [geometry]
                
                # åˆ‡åˆ†æ¯ä¸ªå¤šè¾¹å½¢
                for poly_idx, polygon in enumerate(polygons):
                    parts = split_polygon_into_n_parts(polygon, n_parts)
                    
                    # ä¿å­˜æ¯ä¸ªéƒ¨åˆ†
                    for i, part in enumerate(parts[:n_parts], 1):
                        new_row = row.copy()
                        new_row.geometry = part
                        
                        # æ·»åŠ åˆ‡åˆ†ä¿¡æ¯
                        new_row['SPLIT_ID'] = f"{town_name_clean}-{i}"
                        new_row['ORIGINAL_TOWN'] = town_name
                        new_row['SPLIT_PART'] = i
                        new_row['TOTAL_PARTS'] = n_parts
                        
                        single_gdf = gpd.GeoDataFrame([new_row], geometry='geometry', crs=gdf.crs)
                        
                        # ç”Ÿæˆæ–‡ä»¶å
                        if len(polygons) > 1:
                            file_name = f"{town_name_clean}-{poly_idx+1}-{i}"
                        else:
                            file_name = f"{town_name_clean}-{i}"
                        
                        output_path = os.path.join(town_dir, f"{file_name}.shp")
                        
                        try:
                            single_gdf.to_file(output_path, encoding='utf-8')
                            total_files_created += 1
                        except Exception:
                            pass
                
                pbar.update(1)
        
        print(f"\nğŸ‰ åˆ‡åˆ†å®Œæˆ!")
        print(f"ğŸ“Š åˆ›å»ºæ–‡ä»¶: {total_files_created} ä¸ª")
        print(f"ğŸ“ è¾“å‡ºç›®å½•: {town_dir}")
        
        # æ˜¾ç¤ºç”Ÿæˆçš„æ–‡ä»¶
        print(f"\nğŸ“„ ç”Ÿæˆçš„æ–‡ä»¶:")
        shp_files = [f for f in os.listdir(town_dir) if f.endswith('.shp')]
        for file in shp_files:
            print(f"  â€¢ {file}")
        
        return total_files_created
        
    except Exception as e:
        print(f"âŒ å¤„ç†å¤±è´¥: {e}")
        return 0

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # å•ä¸ªæ–‡ä»¶åˆ‡åˆ†ç¤ºä¾‹
    town_shp_file = "åœæ´é•‡.shp"  # æ›¿æ¢ä¸ºæ‚¨çš„ä¹¡é•‡SHPæ–‡ä»¶
    output_base_dir = "å•ä¸ªä¹¡é•‡åˆ‡åˆ†ç»“æœ"
    n_parts = 4
    
    print("ğŸ—ºï¸  å•ä¸ªä¹¡é•‡è¾¹ç•Œåˆ‡åˆ†å·¥å…·")
    print("=" * 40)
    print(f"ç›®æ ‡ç»“æ„: ä¹¡é•‡å/ä¹¡é•‡å-ç¼–å·.shp")
    print("=" * 40)
    
    files_created = split_single_town_shp(
        shp_file=town_shp_file,
        output_base_dir=output_base_dir,
        n_parts=n_parts
    )
    
    if files_created > 0:
        print(f"\nâœ… ä»»åŠ¡å®Œæˆ! ç”Ÿæˆ {files_created} ä¸ªæ–‡ä»¶")
    else:
        print(f"\nâŒ å¤„ç†å¤±è´¥")
```

### æ•ˆæœ

![image-20251107203916757](D:\Code\MarkDown\img\image-20251107203916757.png)

## æœ€åä¸€ä¸ªè·³è½¬